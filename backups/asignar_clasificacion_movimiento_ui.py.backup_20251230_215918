#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Asignaci√≥n de Clasificaci√≥n de Movimientos - Interfaz Gr√°fica
Permite asignar terceros, grupos y conceptos a movimientos bancarios pendientes.

Autor: Antigravity
Fecha: 2025-12-30
"""

import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox
import psycopg2
from datetime import datetime
import re
from thefuzz import fuzz

# Configuraci√≥n de la base de datos
DB_CONFIG = {
    'host': 'localhost',
    'port': 5433,
    'user': 'postgres',
    'password': 'SLB',
    'database': 'Mvtos'
}


class AsignarClasificacionGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("Asignaci√≥n de Clasificaci√≥n de Movimientos")
        self.root.geometry("1400x900")
        self.root.resizable(True, True)
        
        # Variables de estado
        self.movimientos_pendientes = []
        self.movimiento_actual = None
        self.contexto_historico = []
        self.tercero_seleccionado_id = None
        self.grupo_seleccionado_id = None
        self.concepto_seleccionado_id = None
        
        # Variables UI para editor
        self.grupo_combo = None
        self.concepto_combo = None
        
        # Configurar estilo
        style = ttk.Style()
        style.theme_use('clam')
        
        self.setup_ui()
        
        # Log inicial
        self.agregar_log("‚úì Aplicaci√≥n iniciada correctamente", 'success')
        self.agregar_log("üìã Cargando movimientos pendientes...", 'info')
        
        # Cargar movimientos pendientes al inicio
        self.cargar_movimientos_pendientes()
    
    def setup_ui(self):
        """Configura la interfaz de usuario con 3 secciones."""
        # Frame principal
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Configurar expansi√≥n
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        main_frame.columnconfigure(0, weight=1)
        main_frame.rowconfigure(1, weight=1)  # Pendientes
        main_frame.rowconfigure(3, weight=1)  # Contexto
        main_frame.rowconfigure(5, weight=2)  # Editor
        main_frame.rowconfigure(7, weight=1)  # Log
        
        # T√≠tulo
        title_label = ttk.Label(main_frame, text="Asignaci√≥n de Clasificaci√≥n de Movimientos", 
                               font=('Arial', 16, 'bold'))
        title_label.grid(row=0, column=0, pady=(0, 20))
        
        # === SECCI√ìN 1: Movimientos Pendientes (Tercio Superior) ===
        self.setup_seccion_pendientes(main_frame, row=1)
        
        # === SECCI√ìN 2: Contexto Hist√≥rico (Tercio Medio) ===
        self.setup_seccion_contexto(main_frame, row=3)
        
        # === SECCI√ìN 3: Editor (Tercio Inferior) ===
        self.setup_seccion_editor(main_frame, row=5)
        
        # === Log de Eventos ===
        self.setup_log(main_frame, row=7)
    
    def setup_seccion_pendientes(self, parent, row):
        """Configura la secci√≥n de movimientos pendientes."""
        frame = ttk.LabelFrame(parent, text="1. Movimientos Pendientes de Clasificaci√≥n", padding="10")
        frame.grid(row=row, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 10))
        frame.columnconfigure(0, weight=1)
        frame.rowconfigure(1, weight=1)  # TreeView
        
        # Contador de pendientes
        self.lbl_contador = ttk.Label(frame, text="Movimientos por revisar: 0", 
                                     font=('Arial', 10, 'bold'), foreground='blue')
        self.lbl_contador.grid(row=0, column=0, sticky=tk.W, pady=(0, 5))
        
        # TreeView para movimientos pendientes
        columns = ('id', 'fecha', 'descripcion', 'referencia', 'valor', 'faltante')
        self.pendientes_tree = ttk.Treeview(frame, columns=columns, show='headings', height=8)
        
        self.pendientes_tree.heading('id', text='ID')
        self.pendientes_tree.heading('fecha', text='Fecha')
        self.pendientes_tree.heading('descripcion', text='Descripci√≥n')
        self.pendientes_tree.heading('referencia', text='Referencia')
        self.pendientes_tree.heading('valor', text='Valor')
        self.pendientes_tree.heading('faltante', text='Faltante')
        
        self.pendientes_tree.column('id', width=50)
        self.pendientes_tree.column('fecha', width=100)
        self.pendientes_tree.column('descripcion', width=400)
        self.pendientes_tree.column('referencia', width=150)
        self.pendientes_tree.column('valor', width=120, anchor='e')
        self.pendientes_tree.column('faltante', width=150)
        
        # Scrollbars
        vsb = ttk.Scrollbar(frame, orient="vertical", command=self.pendientes_tree.yview)
        hsb = ttk.Scrollbar(frame, orient="horizontal", command=self.pendientes_tree.xview)
        self.pendientes_tree.configure(yscrollcommand=vsb.set, xscrollcommand=hsb.set)
        
        self.pendientes_tree.grid(row=1, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        vsb.grid(row=1, column=1, sticky=(tk.N, tk.S))
        hsb.grid(row=2, column=0, sticky=(tk.W, tk.E))
        
        # Bind para selecci√≥n
        self.pendientes_tree.bind('<Double-Button-1>', self.seleccionar_movimiento)
        
        # Botones
        btn_frame = ttk.Frame(frame)
        btn_frame.grid(row=3, column=0, pady=(10, 0))
        
        self.refresh_button = ttk.Button(btn_frame, text="üîÑ Actualizar Lista", 
                                        command=self.cargar_movimientos_pendientes, width=20)
        self.refresh_button.grid(row=0, column=0, padx=5)
    
    def setup_seccion_contexto(self, parent, row):
        """Configura la secci√≥n de contexto hist√≥rico."""
        frame = ttk.LabelFrame(parent, text="2. Contexto: √öltimos 5 Movimientos Completos", padding="10")
        frame.grid(row=row, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 10))
        frame.columnconfigure(0, weight=1)
        frame.rowconfigure(0, weight=1)
        
        # TreeView para contexto
        columns = ('fecha', 'descripcion', 'referencia', 'tercero', 'grupo', 'concepto')
        self.contexto_tree = ttk.Treeview(frame, columns=columns, show='headings', height=5)
        
        self.contexto_tree.heading('fecha', text='Fecha')
        self.contexto_tree.heading('descripcion', text='Descripci√≥n')
        self.contexto_tree.heading('referencia', text='Referencia')
        self.contexto_tree.heading('tercero', text='Tercero')
        self.contexto_tree.heading('grupo', text='Grupo')
        self.contexto_tree.heading('concepto', text='Concepto')
        
        self.contexto_tree.column('fecha', width=100)
        self.contexto_tree.column('descripcion', width=300)
        self.contexto_tree.column('referencia', width=150)
        self.contexto_tree.column('tercero', width=200)
        self.contexto_tree.column('grupo', width=150)
        self.contexto_tree.column('concepto', width=200)
        
        # Scrollbars
        vsb = ttk.Scrollbar(frame, orient="vertical", command=self.contexto_tree.yview)
        hsb = ttk.Scrollbar(frame, orient="horizontal", command=self.contexto_tree.xview)
        self.contexto_tree.configure(yscrollcommand=vsb.set, xscrollcommand=hsb.set)
        
        self.contexto_tree.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        vsb.grid(row=0, column=1, sticky=(tk.N, tk.S))
        hsb.grid(row=1, column=0, sticky=(tk.W, tk.E))
    
    def setup_seccion_editor(self, parent, row):
        """Configura la secci√≥n de editor/asignaci√≥n."""
        frame = ttk.LabelFrame(parent, text="3. Editar Movimiento Seleccionado", padding="5")
        frame.grid(row=row, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 10))
        frame.columnconfigure(0, weight=1)
        frame.columnconfigure(1, weight=1)
        
        current_row = 0
        
        # Informaci√≥n del movimiento (solo lectura)
        info_frame = ttk.LabelFrame(frame, text="Informaci√≥n del Movimiento", padding="3")
        info_frame.grid(row=current_row, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 5))
        current_row += 1
        
        self.lbl_mov_fecha = ttk.Label(info_frame, text="Fecha: -")
        self.lbl_mov_fecha.grid(row=0, column=0, sticky=tk.W, padx=5)
        
        self.lbl_mov_desc = ttk.Label(info_frame, text="Descripci√≥n: -")
        self.lbl_mov_desc.grid(row=0, column=1, sticky=tk.W, padx=5)
        
        self.lbl_mov_ref = ttk.Label(info_frame, text="Referencia: -")
        self.lbl_mov_ref.grid(row=1, column=0, sticky=tk.W, padx=5)
        
        self.lbl_mov_valor = ttk.Label(info_frame, text="Valor: -")
        self.lbl_mov_valor.grid(row=1, column=1, sticky=tk.W, padx=5)
        
        self.lbl_patron = ttk.Label(info_frame, text="", foreground='blue', font=('Arial', 8, 'bold'))
        self.lbl_patron.grid(row=2, column=0, columnspan=2, sticky=tk.W, padx=5)
        
        # === TERCERO ===
        tercero_frame = ttk.Frame(frame)
        tercero_frame.grid(row=current_row, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 3), padx=3)
        tercero_frame.columnconfigure(1, weight=1)
        current_row += 1
        
        ttk.Label(tercero_frame, text="Tercero:", font=('Arial', 9, 'bold')).grid(row=0, column=0, sticky=tk.W, padx=2)
        
        # Frame para tercero actual o b√∫squeda
        tercero_content = ttk.Frame(tercero_frame)
        tercero_content.grid(row=0, column=1, sticky=(tk.W, tk.E), padx=2)
        tercero_content.columnconfigure(0, weight=1)
        
        self.lbl_tercero_actual = ttk.Label(tercero_content, text="-")
        self.lbl_tercero_actual.grid(row=0, column=0, sticky=tk.W)
        
        # Combo para buscar tercero (inicialmente oculto)
        self.tercero_combo = ttk.Combobox(tercero_content, width=35)
        self.tercero_combo.bind('<<ComboboxSelected>>', self.on_tercero_seleccionado)
        self.tercero_combo.bind('<KeyRelease>', self.filtrar_terceros)
        
        # Bot√≥n para cambiar tercero o crear nuevo
        self.btn_cambiar_tercero = ttk.Button(tercero_content, text="Cambiar", 
                                             command=self.mostrar_busqueda_tercero, width=10)
        self.btn_crear_tercero = ttk.Button(tercero_content, text="+ Nuevo", 
                                           command=self.crear_nuevo_tercero, width=10)
        
        # === GRUPO ===
        grupo_frame = ttk.Frame(frame)
        grupo_frame.grid(row=current_row, column=0, sticky=(tk.W, tk.E), pady=(0, 3), padx=3)
        grupo_frame.columnconfigure(1, weight=1)
        
        ttk.Label(grupo_frame, text="Grupo:", font=('Arial', 9, 'bold')).grid(row=0, column=0, sticky=tk.W, padx=2)
        self.grupo_combo = ttk.Combobox(grupo_frame, width=35)
        self.grupo_combo.grid(row=0, column=1, sticky=(tk.W, tk.E), padx=2)
        self.grupo_combo.bind('<<ComboboxSelected>>', self.on_grupo_seleccionado)
        self.grupo_combo.bind('<KeyRelease>', self.filtrar_grupos)
        
        self.lbl_grupo_sugerido = ttk.Label(grupo_frame, text="", foreground='green', font=('Arial', 7, 'italic'))
        self.lbl_grupo_sugerido.grid(row=1, column=0, columnspan=2, sticky=tk.W, padx=2)
        
        # === CONCEPTO ===
        concepto_frame = ttk.Frame(frame)
        concepto_frame.grid(row=current_row, column=1, sticky=(tk.W, tk.E), pady=(0, 3), padx=3)
        concepto_frame.columnconfigure(1, weight=1)
        current_row += 1
        
        ttk.Label(concepto_frame, text="Concepto:", font=('Arial', 9, 'bold')).grid(row=0, column=0, sticky=tk.W, padx=2)
        self.concepto_combo = ttk.Combobox(concepto_frame, width=35)
        self.concepto_combo.grid(row=0, column=1, sticky=(tk.W, tk.E), padx=2)
        self.concepto_combo.bind('<<ComboboxSelected>>', self.on_concepto_seleccionado)
        self.concepto_combo.bind('<KeyRelease>', self.filtrar_conceptos)
        
        self.lbl_concepto_sugerido = ttk.Label(concepto_frame, text="", foreground='green', font=('Arial', 7, 'italic'))
        self.lbl_concepto_sugerido.grid(row=1, column=0, columnspan=2, sticky=tk.W, padx=2)
        
        # Botones de acci√≥n
        btn_frame = ttk.Frame(frame)
        btn_frame.grid(row=current_row, column=0, columnspan=2, pady=(10, 0))
        
        self.update_button = ttk.Button(btn_frame, text="‚úì Actualizar Registro", 
                                       command=self.actualizar_registro, state='disabled', width=20)
        self.update_button.grid(row=0, column=0, padx=5)
        
        self.skip_button = ttk.Button(btn_frame, text="‚è≠ Saltar", 
                                     command=self.saltar_movimiento, width=15)
        self.skip_button.grid(row=0, column=1, padx=5)
    
    def setup_log(self, parent, row):
        """Configura el √°rea de log."""
        log_frame = ttk.LabelFrame(parent, text="Log de Eventos", padding="5")
        log_frame.grid(row=row, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        log_frame.columnconfigure(0, weight=1)
        log_frame.rowconfigure(0, weight=1)
        
        self.log_text = scrolledtext.ScrolledText(log_frame, height=8, width=80, 
                                                   font=('Courier', 9), state='disabled')
        self.log_text.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Configurar colores
        self.log_text.tag_config('success', foreground='green')
        self.log_text.tag_config('error', foreground='red')
        self.log_text.tag_config('warning', foreground='orange')
        self.log_text.tag_config('info', foreground='blue')
    
    def agregar_log(self, mensaje, tipo='info'):
        """Agrega un mensaje al log con timestamp."""
        timestamp = datetime.now().strftime("%H:%M:%S")
        self.log_text.config(state='normal')
        self.log_text.insert(tk.END, f"[{timestamp}] {mensaje}\n", tipo)
        self.log_text.see(tk.END)
        self.log_text.config(state='disabled')
        self.root.update_idletasks()
    
    def cargar_movimientos_pendientes(self):
        """Carga los movimientos que faltan tercero, grupo o concepto."""
        try:
            conn = psycopg2.connect(**DB_CONFIG)
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT Id, Fecha, Descripcion, Referencia, Valor,
                       TerceroID, GrupoID, ConceptoID
                FROM movimientos
                WHERE TerceroID IS NULL 
                   OR GrupoID IS NULL 
                   OR ConceptoID IS NULL
                ORDER BY Fecha ASC
                LIMIT 100
            """)
            
            self.movimientos_pendientes = cursor.fetchall()
            
            # Limpiar TreeView
            for item in self.pendientes_tree.get_children():
                self.pendientes_tree.delete(item)
            
            # Poblar TreeView
            for mov in self.movimientos_pendientes:
                mov_id, fecha, desc, ref, valor, tercero_id, grupo_id, concepto_id = mov
                
                # Determinar qu√© falta
                faltantes = []
                if tercero_id is None:
                    faltantes.append("Tercero")
                if grupo_id is None:
                    faltantes.append("Grupo")
                if concepto_id is None:
                    faltantes.append("Concepto")
                
                faltante_str = ", ".join(faltantes)
                
                self.pendientes_tree.insert('', 'end', values=(
                    mov_id,
                    fecha.strftime('%Y-%m-%d'),
                    desc[:50],
                    ref if ref else '',
                    f"${valor:,.2f}",
                    faltante_str
                ))
            
            cursor.close()
            conn.close()
            
            # Actualizar contador
            self.lbl_contador.config(text=f"Movimientos por revisar: {len(self.movimientos_pendientes)}")
            
            self.agregar_log(f"‚úì Cargados {len(self.movimientos_pendientes)} movimientos pendientes", 'success')
            
        except Exception as e:
            self.agregar_log(f"‚úó Error al cargar movimientos: {e}", 'error')
    
    def seleccionar_movimiento(self, event):
        """Maneja la selecci√≥n de un movimiento pendiente."""
        selection = self.pendientes_tree.selection()
        if not selection:
            return
        
        item = self.pendientes_tree.item(selection[0])
        mov_id = item['values'][0]
        
        self.agregar_log(f"üìù Seleccionado movimiento ID={mov_id}", 'info')
        
        # TODO: Cargar detalles completos y contexto hist√≥rico
        self.cargar_movimiento_completo(mov_id)
    
    def cargar_movimiento_completo(self, mov_id):
        """Carga los detalles completos del movimiento seleccionado."""
        try:
            conn = psycopg2.connect(**DB_CONFIG)
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT Id, Fecha, Descripcion, Referencia, Valor,
                       TerceroID, GrupoID, ConceptoID
                FROM movimientos
                WHERE Id = %s
            """, (mov_id,))
            
            self.movimiento_actual = cursor.fetchone()
            
            if self.movimiento_actual:
                mov_id, fecha, desc, ref, valor, tercero_id, grupo_id, concepto_id = self.movimiento_actual
                
                # Actualizar labels
                self.lbl_mov_fecha.config(text=f"Fecha: {fecha.strftime('%Y-%m-%d')}")
                self.lbl_mov_desc.config(text=f"Descripci√≥n: {desc}")
                self.lbl_mov_ref.config(text=f"Referencia: {ref if ref else '(vac√≠a)'}")
                self.lbl_mov_valor.config(text=f"Valor: ${valor:,.2f}")
                
                # Detectar patr√≥n en referencia
                patron = self.detectar_patron_referencia(ref)
                if patron:
                    if patron == 'celular':
                        self.lbl_patron.config(text="üì± Celular detectado en referencia")
                    elif patron == 'cuenta':
                        self.lbl_patron.config(text="üè¶ Cuenta bancaria detectada en referencia")
                else:
                    self.lbl_patron.config(text="")
                
                # Cargar contexto hist√≥rico
                self.cargar_contexto_historico(fecha, ref, patron, tercero_id, grupo_id, concepto_id)
            
            cursor.close()
            conn.close()
            
        except Exception as e:
            self.agregar_log(f"‚úó Error al cargar movimiento: {e}", 'error')
    
    def detectar_patron_referencia(self, referencia):
        """Detecta si una referencia se asemeja a cuenta bancaria o celular."""
        if not referencia:
            return None
        
        # Limpiar string (solo d√≠gitos)
        solo_digitos = ''.join(c for c in referencia if c.isdigit())
        
        # Celular colombiano: 10 d√≠gitos, empieza con 3
        if len(solo_digitos) == 10 and solo_digitos[0] == '3':
            return 'celular'
        
        # Cuenta bancaria: 10-16 d√≠gitos
        if 10 <= len(solo_digitos) <= 16:
            return 'cuenta'
        
        return None
    
    def cargar_contexto_historico(self, fecha_mov, referencia_mov, patron, tercero_id, grupo_id, concepto_id):
        """Carga los 5 registros anteriores completos."""
        try:
            conn = psycopg2.connect(**DB_CONFIG)
            cursor = conn.cursor()
            
            # Decidir consulta seg√∫n patr√≥n
            if patron and referencia_mov:
                # Filtrar por referencia espec√≠fica
                cursor.execute("""
                    SELECT m.Fecha, m.Descripcion, m.Referencia, 
                           t.tercero, g.grupo, c.concepto,
                           m.TerceroID, m.GrupoID, m.ConceptoID
                    FROM movimientos m
                    LEFT JOIN terceros t ON m.TerceroID = t.terceroid
                    LEFT JOIN grupos g ON m.GrupoID = g.grupoid
                    LEFT JOIN conceptos c ON m.ConceptoID = c.conceptoid
                    WHERE m.Referencia = %s
                      AND m.Fecha < %s
                      AND m.TerceroID IS NOT NULL
                      AND m.GrupoID IS NOT NULL
                      AND m.ConceptoID IS NOT NULL
                    ORDER BY m.Fecha DESC
                    LIMIT 5
                """, (referencia_mov, fecha_mov))
                self.agregar_log(f"üîç Buscando contexto con referencia: {referencia_mov}", 'info')
            else:
                # Sin filtro espec√≠fico
                cursor.execute("""
                    SELECT m.Fecha, m.Descripcion, m.Referencia, 
                           t.tercero, g.grupo, c.concepto,
                           m.TerceroID, m.GrupoID, m.ConceptoID
                    FROM movimientos m
                    LEFT JOIN terceros t ON m.TerceroID = t.terceroid
                    LEFT JOIN grupos g ON m.GrupoID = g.grupoid
                    LEFT JOIN conceptos c ON m.ConceptoID = c.conceptoid
                    WHERE m.Fecha < %s
                      AND m.TerceroID IS NOT NULL
                      AND m.GrupoID IS NOT NULL
                      AND m.ConceptoID IS NOT NULL
                    ORDER BY m.Fecha DESC
                    LIMIT 5
                """, (fecha_mov,))
                self.agregar_log(f"üîç Buscando contexto hist√≥rico general", 'info')
            
            self.contexto_historico = cursor.fetchall()
            
            # Limpiar TreeView de contexto
            for item in self.contexto_tree.get_children():
                self.contexto_tree.delete(item)
            
            # Poblar TreeView
            for ctx in self.contexto_historico:
                fecha, desc, ref, tercero, grupo, concepto, tid, gid, cid = ctx
                self.contexto_tree.insert('', 'end', values=(
                    fecha.strftime('%Y-%m-%d'),
                    desc[:40],
                    ref if ref else '',
                    tercero if tercero else '',
                    grupo if grupo else '',
                    concepto if concepto else ''
                ))
            
            self.agregar_log(f"‚úì Cargados {len(self.contexto_historico)} registros de contexto", 'success')
            
            # Mostrar tercero actual si existe
            if tercero_id:
                cursor.execute("SELECT tercero FROM terceros WHERE terceroid = %s", (tercero_id,))
                tercero_nombre = cursor.fetchone()
                if tercero_nombre:
                    self.lbl_tercero_actual.config(text=f"{tercero_id} - {tercero_nombre[0]}", foreground='green')
                    self.lbl_tercero_actual.grid(row=0, column=0, sticky=tk.W)
                    self.btn_cambiar_tercero.grid(row=0, column=1, padx=2)
                    self.btn_crear_tercero.grid_forget()
                    self.tercero_combo.grid_forget()
                    self.tercero_seleccionado_id = tercero_id
            else:
                self.lbl_tercero_actual.config(text="(Sin asignar)", foreground='red')
                self.lbl_tercero_actual.grid_forget()
                # Mostrar combo de b√∫squeda  
                self.tercero_combo.grid(row=0, column=0, sticky=(tk.W, tk.E))
                self.btn_crear_tercero.grid(row=0, column=1, padx=2)
                self.btn_cambiar_tercero.grid_forget()
                # Cargar lista de terceros con fuzzy matching si hay descripci√≥n
                self.cargar_terceros_para_busqueda(desc)
                self.tercero_seleccionado_id = None
            
            # Cargar y analizar grupos y conceptos
            self.cargar_grupos_conceptos(grupo_id, concepto_id)
            
            cursor.close()
            conn.close()
            
        except Exception as e:
            self.agregar_log(f"‚úó Error al cargar contexto: {e}", 'error')
    
    def cargar_grupos_conceptos(self, grupo_id_actual, concepto_id_actual):
        """Carga los grupos y conceptos, sugiere basado en contexto."""
        try:
            conn = psycopg2.connect(**DB_CONFIG)
            cursor = conn.cursor()
            
            # Cargar todos los grupos
            cursor.execute("SELECT grupoid, grupo FROM grupos ORDER BY grupo")
            grupos = cursor.fetchall()
            
            # Guardar listas completas para filtrado
            self.grupos_completos = grupos
            self.grupo_combo['values'] = [f"{gid}: {nombre}" for gid, nombre in grupos]
            
            # Cargar todos los conceptos (sin filtro por ahora)
            cursor.execute("SELECT conceptoid, concepto, grupoid_fk FROM conceptos ORDER BY concepto")
            conceptos = cursor.fetchall()
            
            # Guardar lista completa de conceptos con grupoid_fk
            self.conceptos_completos = conceptos  # Ahora incluye grupoid_fk
            
            # Inicialmente mostrar todos los conceptos
            self.concepto_combo['values'] = [f"{cid}: {nombre}" for cid, nombre, gid in conceptos]
            
            # Analizar contexto para sugerencias
            if self.contexto_historico:
                # Extraer grupos y conceptos del contexto
                grupos_ctx = [ctx[7] for ctx in self.contexto_historico if ctx[7]]  # GrupoID
                conceptos_ctx = [ctx[8] for ctx in self.contexto_historico if ctx[8]]  # ConceptoID
                
                # Si todos los registros del contexto tienen el mismo grupo
                if grupos_ctx and len(set(grupos_ctx)) == 1:
                    grupo_sugerido_id = grupos_ctx[0]
                    cursor.execute("SELECT grupo FROM grupos WHERE grupoid = %s", (grupo_sugerido_id,))
                    grupo_nombre = cursor.fetchone()
                    if grupo_nombre:
                        self.lbl_grupo_sugerido.config(text=f"‚úì Sugerido: {grupo_nombre[0]} (basado en contexto)")
                        # Preseleccionar en combo
                        for idx, val in enumerate(self.grupo_combo['values']):
                            if val.startswith(f"{grupo_sugerido_id}:"):
                                self.grupo_combo.current(idx)
                                self.grupo_seleccionado_id = grupo_sugerido_id
                                # Filtrar conceptos por este grupo
                                self.filtrar_conceptos_por_grupo()
                                break
                
                # Si todos los registros del contexto tienen el mismo concepto
                if conceptos_ctx and len(set(conceptos_ctx)) == 1:
                    concepto_sugerido_id = conceptos_ctx[0]
                    cursor.execute("SELECT concepto FROM conceptos WHERE conceptoid = %s", (concepto_sugerido_id,))
                    concepto_nombre = cursor.fetchone()
                    if concepto_nombre:
                        self.lbl_concepto_sugerido.config(text=f"‚úì Sugerido: {concepto_nombre[0]} (basado en contexto)")
                        # Preseleccionar en combo
                        for idx, val in enumerate(self.concepto_combo['values']):
                            if val.startswith(f"{concepto_sugerido_id}:"):
                                self.concepto_combo.current(idx)
                                self.concepto_seleccionado_id = concepto_sugerido_id
                                break
            
            # Validar si se puede actualizar
            self.validar_actualizacion()
            
            # Guardar listas completas para filtrado
            self.grupos_completos = grupos
            self.conceptos_completos = conceptos
            
            cursor.close()
            conn.close()
            
        except Exception as e:
            self.agregar_log(f"‚úó Error al cargar grupos/conceptos: {e}", 'error')
    
    def filtrar_grupos(self, event):
        """Filtra grupos mientras el usuario escribe."""
        texto_busqueda = self.grupo_combo.get().lower()
        
        if not hasattr(self, 'grupos_completos'):
            return
        
        if texto_busqueda:
            grupos_filtrados = [(gid, nombre) for gid, nombre in self.grupos_completos 
                               if texto_busqueda in nombre.lower() or texto_busqueda in str(gid)]
        else:
            grupos_filtrados = self.grupos_completos
        
        self.grupo_combo['values'] = [f"{gid}: {nombre}" for gid, nombre in grupos_filtrados]
    
    def filtrar_conceptos(self, event):
        """Filtra conceptos mientras el usuario escribe."""
        texto_busqueda = self.concepto_combo.get().lower()
        
        if not hasattr(self, 'conceptos_completos'):
            return
        
        # Filtrar por grupo si hay uno seleccionado
        if self.grupo_seleccionado_id:
            conceptos_base = [(cid, nombre) for cid, nombre, gid in self.conceptos_completos 
                             if gid == self.grupo_seleccionado_id]
        else:
            conceptos_base = [(cid, nombre) for cid, nombre, gid in self.conceptos_completos]
        
        # Filtrar por texto
        if texto_busqueda:
            conceptos_filtrados = [(cid, nombre) for cid, nombre in conceptos_base 
                                  if texto_busqueda in nombre.lower() or texto_busqueda in str(cid)]
        else:
            conceptos_filtrados = conceptos_base
        
        self.concepto_combo['values'] = [f"{cid}: {nombre}" for cid, nombre in conceptos_filtrados]
    
    def filtrar_conceptos_por_grupo(self):
        """Filtra los conceptos bas√°ndose en el grupo seleccionado."""
        if not hasattr(self, 'conceptos_completos'):
            return
        
        if self.grupo_seleccionado_id:
            conceptos_filtrados = [(cid, nombre) for cid, nombre, gid in self.conceptos_completos 
                                  if gid == self.grupo_seleccionado_id]
            self.concepto_combo['values'] = [f"{cid}: {nombre}" for cid, nombre in conceptos_filtrados]
            self.concepto_combo.set('')  # Limpiar selecci√≥n
            self.concepto_seleccionado_id = None
            self.lbl_concepto_sugerido.config(text="")
        else:
            # Mostrar todos
            self.concepto_combo['values'] = [f"{cid}: {nombre}" for cid, nombre, gid in self.conceptos_completos]
    
    def on_grupo_seleccionado(self, event):
        """Maneja la selecci√≥n de un grupo."""
        seleccion = self.grupo_combo.get()
        if seleccion and ':' in seleccion:
            # Extraer ID del formato "ID: Nombre"
            self.grupo_seleccionado_id = int(seleccion.split(':')[0])
            self.agregar_log(f"Grupo seleccionado: ID={self.grupo_seleccionado_id}", 'info')
            # Filtrar conceptos por este grupo
            self.filtrar_conceptos_por_grupo()
            self.validar_actualizacion()
    
    def on_concepto_seleccionado(self, event):
        """Maneja la selecci√≥n de un concepto."""
        seleccion = self.concepto_combo.get()
        if seleccion and ':' in seleccion:
            # Extraer ID del formato "ID: Nombre"
            self.concepto_seleccionado_id = int(seleccion.split(':')[0])
            self.agregar_log(f"Concepto seleccionado: ID={self.concepto_seleccionado_id}", 'info')
            self.validar_actualizacion()
    
    def validar_actualizacion(self):
        """Valida si se puede habilitar el bot√≥n actualizar."""
        if not self.movimiento_actual:
            self.update_button.config(state='disabled')
            return
        
        mov_id, fecha, desc, ref, valor, tercero_id, grupo_id, concepto_id = self.movimiento_actual
        
        # Determinar qu√© falta
        falta_tercero = tercero_id is None
        falta_grupo = grupo_id is None
        falta_concepto = concepto_id is None
        
        # Para poder actualizar:
        # - Si falta grupo, debe estar seleccionado
        # - Si falta concepto, debe estar seleccionado
        # - Tercero ya est√° OK (o tambi√©n debe seleccionarse en el futuro)
        
        puede_actualizar = True
        
        if falta_tercero and self.tercero_seleccionado_id is None:
            puede_actualizar = False
        
        if falta_grupo and self.grupo_seleccionado_id is None:
            puede_actualizar = False
        
        if falta_concepto and self.concepto_seleccionado_id is None:
            puede_actualizar = False
        
        if puede_actualizar:
            self.update_button.config(state='normal')
        else:
            self.update_button.config(state='disabled')
    
    def actualizar_registro(self):
        """Actualiza el movimiento con los valores seleccionados."""
        if not self.movimiento_actual:
            return
        
        mov_id, fecha, desc, ref, valor, tercero_id, grupo_id, concepto_id = self.movimiento_actual
        
        # Construir UPDATE din√°micamente
        updates = []
        params = []
        
        if tercero_id is None and self.tercero_seleccionado_id:
            updates.append("TerceroID = %s")
            params.append(self.tercero_seleccionado_id)
        
        if grupo_id is None and self.grupo_seleccionado_id:
            updates.append("GrupoID = %s")
            params.append(self.grupo_seleccionado_id)
        
        if concepto_id is None and self.concepto_seleccionado_id:
            updates.append("ConceptoID = %s")
            params.append(self.concepto_seleccionado_id)
        
        if not updates:
            self.agregar_log("‚ö† No hay cambios para actualizar", 'warning')
            return
        
        try:
            conn = psycopg2.connect(**DB_CONFIG)
            cursor = conn.cursor()
            
            sql = f"UPDATE movimientos SET {', '.join(updates)} WHERE Id = %s"
            params.append(mov_id)
            
            cursor.execute(sql, params)
            conn.commit()
            
            self.agregar_log(f"‚úì Movimiento ID={mov_id} actualizado exitosamente", 'success')
            
            cursor.close()
            conn.close()
            
            # Recargar lista de pendientes
            self.cargar_movimientos_pendientes()
            
            # Limpiar editor
            self.limpiar_editor()
            
            # Mensaje de √©xito
            messagebox.showinfo("√âxito", f"Movimiento ID={mov_id} actualizado correctamente")
            
        except Exception as e:
            self.agregar_log(f"‚úó Error al actualizar: {e}", 'error')
            messagebox.showerror("Error", f"Error al actualizar:\n{e}")
    
    def limpiar_editor(self):
        """Limpia los campos del editor."""
        self.movimiento_actual = None
        self.grupo_seleccionado_id = None
        self.concepto_seleccionado_id = None
        
        self.lbl_mov_fecha.config(text="Fecha: -")
        self.lbl_mov_desc.config(text="Descripci√≥n: -")
        self.lbl_mov_ref.config(text="Referencia: -")
        self.lbl_mov_valor.config(text="Valor: -")
        self.lbl_patron.config(text="")
        self.lbl_tercero_actual.config(text="-")
        
        self.grupo_combo.set('')
        self.concepto_combo.set('')
        self.lbl_grupo_sugerido.config(text="")
        self.lbl_concepto_sugerido.config(text="")
        
        # Limpiar contexto
        for item in self.contexto_tree.get_children():
            self.contexto_tree.delete(item)
        
        self.update_button.config(state='disabled')
    
    def saltar_movimiento(self):
        """Salta al siguiente movimiento pendiente."""
        self.limpiar_editor()
        self.agregar_log("‚è≠ Editor limpiado - selecciona otro movimiento", 'info')

    def cargar_terceros_para_busqueda(self, descripcion_mov=None):
        """Carga la lista de terceros, con fuzzy matching si hay descripci√≥n."""
        try:
            conn = psycopg2.connect(**DB_CONFIG)
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT terceroid, tercero, descripcion, referencia
                FROM terceros
                ORDER BY tercero, descripcion
            """)
            
            terceros = cursor.fetchall()
            self.terceros_completos = terceros
            
            # Si hay descripci√≥n del movimiento, usar fuzzy matching
            if descripcion_mov and len(terceros) > 0:
                # Calcular similitud para cada tercero
                terceros_con_score = []
                for tid, tercero, desc, ref in terceros:
                    if desc:  # Solo comparar si el tercero tiene descripci√≥n
                        # Usar ratio para similitud general
                        score = fuzz.ratio(descripcion_mov.lower(), desc.lower())
                        terceros_con_score.append((tid, tercero, desc, ref, score))
                    else:
                        terceros_con_score.append((tid, tercero, desc, ref, 0))
                
                # Ordenar por score descendente
                terceros_con_score.sort(key=lambda x: x[4], reverse=True)
                
                # Filtrar solo los que tienen m√°s de 60% de similitud
                UMBRAL_SIMILITUD = 60
                terceros_similares = [(tid, t, d, r, s) for tid, t, d, r, s in terceros_con_score if s >= UMBRAL_SIMILITUD]
                
                if terceros_similares:
                    # Mostrar solo los similares con porcentaje
                    self.tercero_combo['values'] = [
                        f"{tid}: {tercero} - {desc if desc else '(sin desc)'} ({score}%)" 
                        for tid, tercero, desc, ref, score in terceros_similares
                    ]
                    self.agregar_log(f"‚úì Encontrados {len(terceros_similares)} terceros similares a '{descripcion_mov[:30]}...'", 'success')
                else:
                    # No hay similares, mostrar todos
                    self.tercero_combo['values'] = [
                        f"{tid}: {tercero} - {desc if desc else '(sin desc)'}" 
                        for tid, tercero, desc, ref in terceros
                    ]
                    self.agregar_log(f"‚ö† No hay terceros similares. Mostrando todos ({len(terceros)})", 'warning')
            else:
                # Sin descripci√≥n, mostrar todos
                self.tercero_combo['values'] = [
                    f"{tid}: {tercero} - {desc if desc else '(sin desc)'}" 
                    for tid, tercero, desc, ref in terceros
                ]
                self.agregar_log(f"‚úì Cargados {len(terceros)} terceros", 'info')
            
            cursor.close()
            conn.close()
            
        except Exception as e:
            self.agregar_log(f"‚úó Error al cargar terceros: {e}", 'error')
    
    def filtrar_terceros(self, event):
        """Filtra terceros mientras el usuario escribe."""
        texto_busqueda = self.tercero_combo.get().lower()
        
        if not hasattr(self, 'terceros_completos'):
            return
        
        if texto_busqueda:
            terceros_filtrados = [
                (tid, tercero, desc, ref) for tid, tercero, desc, ref in self.terceros_completos 
                if texto_busqueda in tercero.lower() or 
                   (desc and texto_busqueda in desc.lower()) or
                   texto_busqueda in str(tid)
            ]
        else:
            terceros_filtrados = self.terceros_completos
        
        self.tercero_combo['values'] = [
            f"{tid}: {tercero} - {desc if desc else '(sin desc)'}" 
            for tid, tercero, desc, ref in terceros_filtrados
        ]
    
    def on_tercero_seleccionado(self, event):
        """Maneja la selecci√≥n de un tercero."""
        seleccion = self.tercero_combo.get()
        if seleccion and ':' in seleccion:
            # Extraer ID del formato "ID: Nombre - Descripcion"
            self.tercero_seleccionado_id = int(seleccion.split(':')[0])
            self.agregar_log(f"Tercero seleccionado: ID={self.tercero_seleccionado_id}", 'info')
            self.validar_actualizacion()
    
    def mostrar_busqueda_tercero(self):
        """Muestra el combo de b√∫squeda de tercero."""
        self.lbl_tercero_actual.grid_forget()
        self.btn_cambiar_tercero.grid_forget()
        self.tercero_combo.grid(row=0, column=0, sticky=(tk.W, tk.E))
        self.btn_crear_tercero.grid(row=0, column=1, padx=2)
        self.cargar_terceros_para_busqueda()
    
    def crear_nuevo_tercero(self):
        """Abre di√°logo para crear un nuevo tercero."""
        if not self.movimiento_actual:
            return
        
        mov_id, fecha, desc, ref, valor, tercero_id, grupo_id, concepto_id = self.movimiento_actual
        
        # Crear ventana de di√°logo
        dialog = tk.Toplevel(self.root)
        dialog.title("Crear Nuevo Tercero")
        dialog.geometry("500x250")
        dialog.transient(self.root)
        dialog.grab_set()
        
        # Campos
        ttk.Label(dialog, text="Tercero (requerido):", font=('Arial', 9, 'bold')).grid(row=0, column=0, sticky=tk.W, padx=10, pady=5)
        entry_tercero = ttk.Entry(dialog, width=40)
        entry_tercero.grid(row=0, column=1, padx=10, pady=5)
        
        ttk.Label(dialog, text="Descripci√≥n:", font=('Arial', 9, 'bold')).grid(row=1, column=0, sticky=tk.W, padx=10, pady=5)
        entry_desc = ttk.Entry(dialog, width=40)
        entry_desc.grid(row=1, column=1, padx=10, pady=5)
        entry_desc.insert(0, desc if desc else '')  # Pre-poblar con descripci√≥n del movimiento
        
        ttk.Label(dialog, text="Referencia (opcional):", font=('Arial', 9, 'bold')).grid(row=2, column=0, sticky=tk.W, padx=10, pady=5)
        entry_ref = ttk.Entry(dialog, width=40)
        entry_ref.grid(row=2, column=1, padx=10, pady=5)
        entry_ref.insert(0, ref if ref else '')
        
        # Mensaje de ayuda
        ttk.Label(dialog, text="Si la referencia queda vac√≠a, la combinaci√≥n (tercero, descripci√≥n) debe ser √∫nica.", 
                 font=('Arial', 8, 'italic'), foreground='gray').grid(row=3, column=0, columnspan=2, padx=10, pady=5)
        
        def guardar_tercero():
            tercero_nombre = entry_tercero.get().strip()
            descripcion = entry_desc.get().strip()
            referencia = entry_ref.get().strip()
            
            if not tercero_nombre:
                messagebox.showerror("Error", "El campo 'Tercero' es requerido")
                return
            
            try:
                conn = psycopg2.connect(**DB_CONFIG)
                cursor = conn.cursor()
                
                # Insertar nuevo tercero
                cursor.execute("""
                    INSERT INTO terceros (tercero, descripcion, referencia)
                    VALUES (%s, %s, %s)
                    RETURNING terceroid
                """, (tercero_nombre, descripcion if descripcion else None, referencia if referencia else ''))
                
                nuevo_id = cursor.fetchone()[0]
                conn.commit()
                
                self.agregar_log(f"‚úì Tercero creado: ID={nuevo_id}, {tercero_nombre}", 'success')
                
                cursor.close()
                conn.close()
                
                # Seleccionar el nuevo tercero
                self.tercero_seleccionado_id = nuevo_id
                self.tercero_combo.set(f"{nuevo_id}: {tercero_nombre} - {descripcion if descripcion else '(sin desc)'}")
                
                # Recargar lista
                self.cargar_terceros_para_busqueda()
                
                # Validar actualizaci√≥n
                self.validar_actualizacion()
                
                dialog.destroy()
                messagebox.showinfo("√âxito", f"Tercero '{tercero_nombre}' creado correctamente")
                
            except psycopg2.IntegrityError as e:
                conn.rollback()
                self.agregar_log(f"‚úó Error: Tercero duplicado - {e}", 'error')
                messagebox.showerror("Error", f"Ya existe un tercero con esa combinaci√≥n:\n{e}")
            except Exception as e:
                conn.rollback()
                self.agregar_log(f"‚úó Error al crear tercero: {e}", 'error')
                messagebox.showerror("Error", f"Error al crear tercero:\n{e}")
        
        # Botones
        btn_frame = ttk.Frame(dialog)
        btn_frame.grid(row=4, column=0, columnspan=2, pady=20)
        
        ttk.Button(btn_frame, text="Guardar", command=guardar_tercero, width=15).grid(row=0, column=0, padx=5)
        ttk.Button(btn_frame, text="Cancelar", command=dialog.destroy, width=15).grid(row=0, column=1, padx=5)

def main():
    """Funci√≥n principal."""
    root = tk.Tk()
    app = AsignarClasificacionGUI(root)
    root.mainloop()


if __name__ == "__main__":
    main()
