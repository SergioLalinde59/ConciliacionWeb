#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Cargador de Movimientos Bancarios - Interfaz Gr√°fica
Permite cargar movimientos bancarios desde archivos PDF, validando duplicados
contra la base de datos PostgreSQL.

Autor: Antigravity
Fecha: 2025-12-28
"""

import tkinter as tk
from tkinter import ttk, scrolledtext, filedialog, messagebox
import psycopg2
from psycopg2 import sql
from datetime import datetime
from decimal import Decimal
import threading
import os
import sys

# Importar extractores
sys.path.append(os.path.dirname(__file__))
from extractores.bancolombia_extractor import (
    extraer_movimientos_bancolombia,
    obtener_estadisticas
)

# Configuraci√≥n de la base de datos
DB_CONFIG = {
    'host': 'localhost',
    'port': 5433,
    'user': 'postgres',
    'password': 'SLB',
    'database': 'Mvtos'
}

# Funciones auxiliares para detecci√≥n de patrones
def detectar_cuota_manejo(descripcion):
    """
    Detecta si una descripci√≥n corresponde a cuota de manejo.
    Retorna True si coincide con los patrones.
    """
    if not descripcion:
        return False
    
    desc_lower = descripcion.lower()
    patrones = [
        'cuota' in desc_lower and 'manejo' in desc_lower,
        'manejo' in desc_lower and 'tarjeta' in desc_lower,
        'dev' in desc_lower and 'cuota' in desc_lower and 'manejo' in desc_lower
    ]
    
    return any(patrones)


def obtener_contactid_bancolombia(cursor):
    """
    Obtiene el ContactID del contacto 'Bancolombia' con referencia 'Cuota de Manejo'.
    Retorna el ContactID o None si no existe.
    """
    try:
        cursor.execute("""
            SELECT contactoid 
            FROM contactos 
            WHERE contacto = 'Bancolombia' 
              AND referencia = 'Cuota de Manejo'
            LIMIT 1
        """)
        
        result = cursor.fetchone()
        return result[0] if result else None
    except Exception:
        return None


# Configuraci√≥n de cuentas
CUENTAS_CONFIG = {
    'Ahorros': {
        'account_id': 2,
        'extractor': extraer_movimientos_bancolombia,
        'file_filter': [("PDF Files", "*.pdf"), ("All Files", "*.*")]
    },
    'Fondorenta': {
        'account_id': None,  # TODO: definir
        'extractor': None,
        'file_filter': [("All Files", "*.*")]
    },
    'Mc Pesos': {
        'account_id': None,  # TODO: definir
        'extractor': None,
        'file_filter': [("All Files", "*.*")]
    },
    'Mc Dolaras': {
        'account_id': None,  # TODO: definir
        'extractor': None,
        'file_filter': [("All Files", "*.*")]
    },
    'Protecci√≥n': {
        'account_id': None,  # TODO: definir
        'extractor': None,
        'file_filter': [("All Files", "*.*")]
    }
}


class CargadorMovimientosGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("Cargador de Movimientos Bancarios")
        self.root.geometry("1100x800")
        self.root.resizable(True, True)
        
        # Variables
        self.cuenta_seleccionada = tk.StringVar(value="Ahorros")
        self.archivo_pdf = None
        self.movimientos_extraidos = []
        self.movimientos_nuevos = []
        self.movimientos_duplicados = []
        self.running = False
        
        # Configurar estilo
        style = ttk.Style()
        style.theme_use('clam')
        
        self.setup_ui()
        
        # Log inicial
        self.agregar_log("‚úì Aplicaci√≥n iniciada correctamente", 'success')
        self.agregar_log("üìÅ Selecciona una cuenta y un archivo PDF para comenzar", 'info')
    
    def setup_ui(self):
        """Configura la interfaz de usuario."""
        # Frame principal
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Configurar expansi√≥n
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        main_frame.columnconfigure(0, weight=1)
        main_frame.rowconfigure(3, weight=1)  # Preview
        main_frame.rowconfigure(6, weight=1)  # Log
        
        # T√≠tulo
        title_label = ttk.Label(main_frame, text="Cargador de Movimientos Bancarios", 
                               font=('Arial', 16, 'bold'))
        title_label.grid(row=0, column=0, columnspan=2, pady=(0, 20))
        
        # === SECCI√ìN 1: Selecci√≥n de Cuenta y Archivo ===
        selection_frame = ttk.LabelFrame(main_frame, text="1. Selecci√≥n de Cuenta y Archivo", padding="10")
        selection_frame.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        selection_frame.columnconfigure(1, weight=1)
        
        # Selector de cuenta
        ttk.Label(selection_frame, text="Cuenta:").grid(row=0, column=0, sticky=tk.W, padx=(0, 10))
        cuenta_combo = ttk.Combobox(selection_frame, textvariable=self.cuenta_seleccionada,
                                    values=list(CUENTAS_CONFIG.keys()), state='readonly', width=30)
        cuenta_combo.grid(row=0, column=1, sticky=tk.W)
        
        # Selector de archivo
        ttk.Label(selection_frame, text="Archivo:").grid(row=1, column=0, sticky=tk.W, padx=(0, 10), pady=(10, 0))
        self.file_label = ttk.Label(selection_frame, text="Ning√∫n archivo seleccionado", 
                                    foreground='gray', font=('Arial', 9))
        self.file_label.grid(row=1, column=1, sticky=tk.W, pady=(10, 0))
        
        self.browse_button = ttk.Button(selection_frame, text="Seleccionar Archivo...", 
                                       command=self.seleccionar_archivo)
        self.browse_button.grid(row=1, column=2, sticky=tk.E, padx=(10, 0), pady=(10, 0))
        
        # === SECCI√ìN 2: Estad√≠sticas ===
        stats_frame = ttk.LabelFrame(main_frame, text="2. Estad√≠sticas de Validaci√≥n", padding="10")
        stats_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        
        # Container para las tres cajas de estad√≠sticas
        stats_container = ttk.Frame(stats_frame)
        stats_container.grid(row=0, column=0, pady=5)
        
        # Caja 1: Registros Le√≠dos
        box1 = ttk.Frame(stats_container, relief='solid', borderwidth=2)
        box1.grid(row=0, column=0, padx=10)
        ttk.Label(box1, text="üìä Registros Le√≠dos", font=('Arial', 9, 'bold')).pack(pady=(5, 0))
        self.stats_leidos = ttk.Label(box1, text="0", font=('Arial', 20, 'bold'), foreground='blue')
        self.stats_leidos.pack(pady=(0, 5), padx=20)
        
        # Caja 2: Duplicados
        box2 = ttk.Frame(stats_container, relief='solid', borderwidth=2)
        box2.grid(row=0, column=1, padx=10)
        ttk.Label(box2, text="‚ö† Duplicados", font=('Arial', 9, 'bold')).pack(pady=(5, 0))
        self.stats_duplicados = ttk.Label(box2, text="0", font=('Arial', 20, 'bold'), foreground='orange')
        self.stats_duplicados.pack(pady=(0, 5), padx=20)
        
        # Caja 3: A Cargar
        box3 = ttk.Frame(stats_container, relief='solid', borderwidth=2)
        box3.grid(row=0, column=2, padx=10)
        ttk.Label(box3, text="‚úì A Cargar", font=('Arial', 9, 'bold')).pack(pady=(5, 0))
        self.stats_a_cargar = ttk.Label(box3, text="0", font=('Arial', 20, 'bold'), foreground='green')
        self.stats_a_cargar.pack(pady=(0, 5), padx=20)
        
        # === SECCI√ìN 3: Preview de Datos ===
        preview_frame = ttk.LabelFrame(main_frame, text="3. Preview de Todos los Datos Extra√≠dos", padding="10")
        preview_frame.grid(row=3, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 10))
        preview_frame.columnconfigure(0, weight=1)
        preview_frame.rowconfigure(0, weight=1)
        
        # TreeView para mostrar movimientos
        columns = ('fecha', 'descripcion', 'referencia', 'valor')
        self.preview_tree = ttk.Treeview(preview_frame, columns=columns, show='headings', height=8)
        
        self.preview_tree.heading('fecha', text='Fecha')
        self.preview_tree.heading('descripcion', text='Descripci√≥n')
        self.preview_tree.heading('referencia', text='Referencia')
        self.preview_tree.heading('valor', text='Valor')
        
        self.preview_tree.column('fecha', width=100)
        self.preview_tree.column('descripcion', width=500)
        self.preview_tree.column('referencia', width=150)
        self.preview_tree.column('valor', width=120, anchor='e')
        
        # Scrollbars
        vsb = ttk.Scrollbar(preview_frame, orient="vertical", command=self.preview_tree.yview)
        hsb = ttk.Scrollbar(preview_frame, orient="horizontal", command=self.preview_tree.xview)
        self.preview_tree.configure(yscrollcommand=vsb.set, xscrollcommand=hsb.set)
        
        self.preview_tree.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        vsb.grid(row=0, column=1, sticky=(tk.N, tk.S))
        hsb.grid(row=1, column=0, sticky=(tk.W, tk.E))
        
        # === SECCI√ìN 4: Validaci√≥n ===
        validation_frame = ttk.LabelFrame(main_frame, text="4. Validaci√≥n de Duplicados", padding="10")
        validation_frame.grid(row=4, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        validation_frame.columnconfigure(0, weight=1)
        
        self.validation_text = tk.Text(validation_frame, height=10, width=80, font=('Courier', 9))
        self.validation_text.grid(row=0, column=0, sticky=(tk.W, tk.E))
        
        # === SECCI√ìN 5: Progreso y Acciones ===
        action_frame = ttk.LabelFrame(main_frame, text="5. Acciones", padding="10")
        action_frame.grid(row=5, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        action_frame.columnconfigure(0, weight=1)
        
        # Progress bar
        self.progress_bar = ttk.Progressbar(action_frame, mode='determinate', length=400)
        self.progress_bar.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=(0, 10))
        
        # Botones de acci√≥n
        button_container = ttk.Frame(action_frame)
        button_container.grid(row=1, column=0)
        
        self.load_button = ttk.Button(button_container, text="‚úì Cargar Registros Nuevos", 
                                     command=self.cargar_registros, state='disabled', width=25)
        self.load_button.grid(row=0, column=0, padx=5)
        
        self.clear_button = ttk.Button(button_container, text="üóëÔ∏è Limpiar", 
                                      command=self.limpiar_todo, width=20)
        self.clear_button.grid(row=0, column=1, padx=5)
        
        # === SECCI√ìN 6: Log de Eventos ===
        log_frame = ttk.LabelFrame(main_frame, text="Log de Eventos", padding="10")
        log_frame.grid(row=6, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 10))
        log_frame.columnconfigure(0, weight=1)
        log_frame.rowconfigure(0, weight=1)
        
        # √Årea de texto con scroll para el log
        self.log_text = scrolledtext.ScrolledText(log_frame, height=10, width=80, 
                                                   font=('Courier', 9), state='disabled')
        self.log_text.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Configurar colores para el log
        self.log_text.tag_config('success', foreground='green')
        self.log_text.tag_config('error', foreground='red')
        self.log_text.tag_config('warning', foreground='orange')
        self.log_text.tag_config('info', foreground='blue')
    
    def agregar_log(self, mensaje, tipo='info'):
        """Agrega un mensaje al log con timestamp."""
        timestamp = datetime.now().strftime("%H:%M:%S")
        self.log_text.config(state='normal')
        self.log_text.insert(tk.END, f"[{timestamp}] {mensaje}\n", tipo)
        self.log_text.see(tk.END)
        self.log_text.config(state='disabled')
        self.root.update_idletasks()
    
    def seleccionar_archivo(self):
        """Abre un di√°logo para seleccionar el archivo PDF."""
        cuenta = self.cuenta_seleccionada.get()
        config = CUENTAS_CONFIG[cuenta]
        
        if config['extractor'] is None:
            messagebox.showwarning("No Disponible", 
                                  f"El extractor para '{cuenta}' a√∫n no est√° implementado.")
            return
        
        archivo = filedialog.askopenfilename(
            title=f"Seleccionar Archivo de {cuenta}",
            filetypes=config['file_filter'],
            initialdir=os.path.join(os.getcwd(), "MovimientosPendientes")
        )
        
        if archivo:
            self.archivo_pdf = archivo
            nombre_archivo = os.path.basename(archivo)
            self.file_label.config(text=nombre_archivo, foreground='black', font=('Arial', 9, 'bold'))
            self.agregar_log(f"‚úì Archivo seleccionado: {nombre_archivo}", 'success')
            
            # Extraer y mostrar preview
            self.extraer_y_mostrar()
    
    def extraer_y_mostrar(self):
        """Extrae movimientos del PDF y muestra preview."""
        self.agregar_log("üìÇ Extrayendo movimientos del archivo...", 'info')
        
        try:
            cuenta = self.cuenta_seleccionada.get()
            config = CUENTAS_CONFIG[cuenta]
            extractor = config['extractor']
            
            # Extraer movimientos
            self.movimientos_extraidos = extractor(self.archivo_pdf)
            
            if not self.movimientos_extraidos:
                self.agregar_log("‚ö† No se encontraron movimientos en el archivo", 'warning')
                return
            
            # Mostrar estad√≠sticas
            stats = obtener_estadisticas(self.movimientos_extraidos)
            self.agregar_log(f"‚úì Extra√≠dos {stats['total']} movimientos " +
                           f"({stats['debitos']} d√©bitos, {stats['creditos']} cr√©ditos)", 'success')
            
            # Mostrar preview inicial con todos los movimientos
            self.actualizar_preview_todos()
            
            # Ejecutar validaci√≥n autom√°ticamente
            self.validar_duplicados()
            
        except Exception as e:
            self.agregar_log(f"‚úó Error al extraer movimientos: {e}", 'error')
            import traceback
            traceback.print_exc()
    
    def validar_duplicados(self):
        """Valida qu√© movimientos ya existen en la base de datos."""
        if not self.movimientos_extraidos:
            messagebox.showwarning("Advertencia", "No hay movimientos para validar.")
            return
        
        self.agregar_log("üîç Validando duplicados contra la base de datos...", 'info')
        
        # Ejecutar en thread separado
        thread = threading.Thread(target=self._ejecutar_validacion)
        thread.daemon = True
        thread.start()
    
    def _ejecutar_validacion(self):
        """Ejecuta la validaci√≥n de duplicados en background."""
        try:
            # Conectar a la base de datos
            conn = psycopg2.connect(**DB_CONFIG)
            cursor = conn.cursor()
            
            cuenta = self.cuenta_seleccionada.get()
            account_id = CUENTAS_CONFIG[cuenta]['account_id']
            
            self.movimientos_nuevos = []
            self.movimientos_duplicados = []
            
            # Validar cada movimiento
            for mov in self.movimientos_extraidos:
                # Query para buscar duplicados: Fecha + Descripci√≥n + Valor
                cursor.execute("""
                    SELECT COUNT(*) FROM movimientos
                    WHERE AccountID = %s
                      AND Fecha = %s
                      AND Descripcion = %s
                      AND Valor = %s
                """, (account_id, mov['fecha'].date(), mov['descripcion'], mov['valor']))
                
                count = cursor.fetchone()[0]
                
                if count > 0:
                    self.movimientos_duplicados.append(mov)
                    # Log detallado del duplicado encontrado (solo primeros 5)
                    if len(self.movimientos_duplicados) <= 5:
                        self.agregar_log(
                            f"  ‚Üí Duplicado: {mov['fecha'].strftime('%Y-%m-%d')} | " +
                            f"{mov['descripcion'][:30]} | ${mov['valor']:,.2f}", 
                            'warning'
                        )
                else:
                    self.movimientos_nuevos.append(mov)
            
            cursor.close()
            conn.close()
            
            # Mostrar resultados
            self.mostrar_resultados_validacion()
            
            # Actualizar estad√≠sticas visuales
            self.actualizar_estadisticas_visuales()
            
        except Exception as e:
            self.agregar_log(f"‚úó Error al validar duplicados: {e}", 'error')
            import traceback
            traceback.print_exc()
    
    def mostrar_resultados_validacion(self):
        """Muestra los resultados de la validaci√≥n en el √°rea de validaci√≥n."""
        self.validation_text.delete('1.0', tk.END)
        
        total = len(self.movimientos_extraidos)
        nuevos = len(self.movimientos_nuevos)
        duplicados = len(self.movimientos_duplicados)
        
        resultado = f"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë           RESULTADOS DE VALIDACI√ìN DE DUPLICADOS                 ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  Total de movimientos en archivo:    {total:>5}                       ‚ïë
‚ïë  Registros NUEVOS (no en BD):        {nuevos:>5}  ‚úì                   ‚ïë
‚ïë  Registros DUPLICADOS (ya en BD):    {duplicados:>5}  ‚ö†                   ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
"""
        
        # Si hay duplicados, mostrar detalles
        if duplicados > 0:
            resultado += "\n‚ö† MOVIMIENTOS DUPLICADOS (ya existen en la base de datos):\n"
            resultado += "-" * 70 + "\n"
            for i, mov in enumerate(self.movimientos_duplicados[:10], 1):
                resultado += f"{i}. {mov['fecha'].strftime('%Y-%m-%d')} | "
                resultado += f"{mov['descripcion'][:35]:<35} | "
                resultado += f"${mov['valor']:>12,.2f}\n"
            
            if duplicados > 10:
                resultado += f"\n... y {duplicados - 10} duplicados m√°s.\n"
        
        self.validation_text.insert('1.0', resultado)
        
        if duplicados > 0:
            self.agregar_log(f"‚ö† Se encontraron {duplicados} movimientos duplicados (ver detalles arriba)", 'warning')
            self.agregar_log(f"  ‚Üí Estos registros NO se cargar√°n nuevamente", 'warning')
        
        if nuevos > 0:
            self.agregar_log(f"‚úì {nuevos} movimientos nuevos listos para cargar", 'success')
            self.load_button.config(state='normal')
        else:
            self.agregar_log("‚Ñπ No hay movimientos nuevos para cargar", 'info')
            self.load_button.config(state='disabled')
    
    def actualizar_preview_todos(self):
        """Actualiza el preview para mostrar TODOS los movimientos extra√≠dos."""
        # Limpiar preview
        for item in self.preview_tree.get_children():
            self.preview_tree.delete(item)
        
        if not self.movimientos_extraidos:
            return
        
        # Ordenar movimientos por fecha (m√°s antiguos primero)
        movimientos_ordenados = sorted(self.movimientos_extraidos, key=lambda x: x['fecha'])
        
        # Mostrar primeros 20 movimientos ordenados
        for mov in movimientos_ordenados[:20]:
            self.preview_tree.insert('', 'end', values=(
                mov['fecha'].strftime('%Y-%m-%d'),
                mov['descripcion'][:60],  # Truncar descripci√≥n
                mov['referencia'] if mov['referencia'] else '',
                f"${mov['valor']:,.2f}"
            ))
        
        if len(movimientos_ordenados) > 20:
            self.agregar_log(f"  (Preview mostrando primeros 20 de {len(movimientos_ordenados)} movimientos)", 'info')
    
    def actualizar_estadisticas_visuales(self):
        """Actualiza las cajas de estad√≠sticas visuales."""
        total = len(self.movimientos_extraidos)
        duplicados = len(self.movimientos_duplicados)
        nuevos = len(self.movimientos_nuevos)
        
        self.stats_leidos.config(text=str(total))
        self.stats_duplicados.config(text=str(duplicados))
        self.stats_a_cargar.config(text=str(nuevos))
    
    def cargar_registros(self):
        """Carga los registros nuevos a la base de datos."""
        if not self.movimientos_nuevos:
            messagebox.showwarning("Advertencia", "No hay movimientos nuevos para cargar.")
            return
        
        # Confirmar con el usuario
        respuesta = messagebox.askyesno(
            "Confirmar Carga",
            f"¬øEst√°s seguro de que deseas cargar {len(self.movimientos_nuevos)} movimientos " +
            f"a la cuenta '{self.cuenta_seleccionada.get()}'?",
            icon='question'
        )
        
        if not respuesta:
            self.agregar_log("‚ö† Carga cancelada por el usuario", 'warning')
            return
        
        self.agregar_log(f"üì§ Iniciando carga de {len(self.movimientos_nuevos)} movimientos...", 'info')
        self.load_button.config(state='disabled')
        
        # Ejecutar en thread separado
        thread = threading.Thread(target=self._ejecutar_carga)
        thread.daemon = True
        thread.start()
    
    def _ejecutar_carga(self):
        """Ejecuta la carga de registros en background."""
        try:
            # Conectar a la base de datos
            conn = psycopg2.connect(**DB_CONFIG)
            cursor = conn.cursor()
            
            cuenta = self.cuenta_seleccionada.get()
            account_id = CUENTAS_CONFIG[cuenta]['account_id']
            
            # Obtener ContactID de Bancolombia para cuotas de manejo
            contactid_bancolombia = obtener_contactid_bancolombia(cursor)
            if contactid_bancolombia:
                self.agregar_log(f"‚úì ContactID Bancolombia encontrado: {contactid_bancolombia}", 'success')
                self.agregar_log("  ‚Üí Cuotas de manejo se mapear√°n autom√°ticamente", 'info')
            else:
                self.agregar_log("‚ö† ContactID Bancolombia no encontrado. Cuotas de manejo se insertar√°n sin contacto.", 'warning')
            
            sql_insert = """
                INSERT INTO movimientos 
                (Fecha, Descripcion, Referencia, Valor, USD, TRM, 
                 CurencyID, AccountID, ContactID, GrupoID, ConceptoID)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            """
            
            total = len(self.movimientos_nuevos)
            cargados = 0
            errores = 0
            cuotas_manejo_detectadas = 0
            
            self.progress_bar['maximum'] = total
            self.progress_bar['value'] = 0
            
            # Ordenar movimientos por fecha (m√°s antiguos primero)
            movimientos_ordenados = sorted(self.movimientos_nuevos, key=lambda x: x['fecha'])
            
            for i, mov in enumerate(movimientos_ordenados, 1):
                try:
                    # Para AccountID = 2 (Ahorros): USD=0, TRM=0, CurencyID=1
                    # Para otras cuentas: USD=NULL, TRM=NULL, CurencyID=NULL
                    usd_value = 0 if account_id == 2 else None
                    trm_value = 0 if account_id == 2 else None
                    curency_id = 1 if account_id == 2 else None
                    
                    # Detectar si es cuota de manejo
                    es_cuota_manejo = detectar_cuota_manejo(mov['descripcion'])
                    
                    # Determinar ContactID, descripci√≥n y referencia
                    if es_cuota_manejo and contactid_bancolombia:
                        contact_id = contactid_bancolombia
                        descripcion = 'Bancolombia'
                        referencia = 'Cuota de Manejo'
                        cuotas_manejo_detectadas += 1
                    else:
                        contact_id = None
                        descripcion = mov['descripcion'].title()
                        referencia = mov['referencia'] if mov['referencia'] else ''
                    
                    cursor.execute(sql_insert, (
                        mov['fecha'].date(),
                        descripcion,
                        referencia,
                        mov['valor'],
                        usd_value,  # USD - 0 para Ahorros, NULL para otras
                        trm_value,  # TRM - 0 para Ahorros, NULL para otras
                        curency_id,  # CurencyID - 1 para Ahorros, NULL para otras
                        account_id,
                        contact_id,  # ContactID - Bancolombia si es cuota de manejo, NULL si no
                        None,  # GrupoID - NULL
                        None   # ConceptoID - NULL
                    ))
                    cargados += 1
                except Exception as e:
                    errores += 1
                    self.agregar_log(f"‚úó Error en registro {i}: {e}", 'error')
                
                # Actualizar progreso
                self.progress_bar['value'] = i
                if i % 10 == 0 or i == total:
                    self.root.update_idletasks()
            
            # Commit
            conn.commit()
            
            cursor.close()
            conn.close()
            
            # Mostrar resultados
            if errores == 0:
                self.agregar_log(f"‚úì‚úì‚úì CARGA COMPLETADA EXITOSAMENTE ‚úì‚úì‚úì", 'success')
                self.agregar_log(f"‚úì {cargados} movimientos cargados correctamente", 'success')
                if cuotas_manejo_detectadas > 0:
                    self.agregar_log(f"‚úì {cuotas_manejo_detectadas} cuotas de manejo mapeadas autom√°ticamente a Bancolombia", 'success')
                messagebox.showinfo("√âxito", 
                                   f"Se cargaron {cargados} movimientos exitosamente.\n" +
                                   (f"{cuotas_manejo_detectadas} cuotas de manejo mapeadas a Bancolombia." if cuotas_manejo_detectadas > 0 else ""))
            else:
                self.agregar_log(f"‚ö† Carga completada con {errores} errores", 'warning')
                self.agregar_log(f"‚úì {cargados} movimientos cargados, {errores} errores", 'warning')
                if cuotas_manejo_detectadas > 0:
                    self.agregar_log(f"‚úì {cuotas_manejo_detectadas} cuotas de manejo mapeadas autom√°ticamente a Bancolombia", 'success')
                messagebox.showwarning("Completado con errores",
                                      f"Se cargaron {cargados} movimientos.\n{errores} registros tuvieron errores.")
            
            # Resetear
            self.progress_bar['value'] = 0
            
        except Exception as e:
            self.agregar_log(f"‚úó Error cr√≠tico durante la carga: {e}", 'error')
            messagebox.showerror("Error", f"Error durante la carga:\n{e}")
            import traceback
            traceback.print_exc()
        finally:
            self.load_button.config(state='normal')
    
    def limpiar_todo(self):
        """Limpia todos los datos y resetea la interfaz."""
        self.archivo_pdf = None
        self.movimientos_extraidos = []
        self.movimientos_nuevos = []
        self.movimientos_duplicados = []
        
        self.file_label.config(text="Ning√∫n archivo seleccionado", foreground='gray', font=('Arial', 9))
        
        # Limpiar estad√≠sticas visuales
        self.stats_leidos.config(text="0")
        self.stats_duplicados.config(text="0")
        self.stats_a_cargar.config(text="0")
        
        # Limpiar preview
        for item in self.preview_tree.get_children():
            self.preview_tree.delete(item)
        
        # Limpiar validaci√≥n
        self.validation_text.delete('1.0', tk.END)
        
        # Limpiar log
        self.log_text.config(state='normal')
        self.log_text.delete('1.0', tk.END)
        self.log_text.config(state='disabled')
        
        # Resetear botones
        self.load_button.config(state='disabled')
        self.progress_bar['value'] = 0
        
        self.agregar_log("‚úì Interfaz limpiada", 'success')
        self.agregar_log("üìÅ Selecciona una cuenta y un archivo PDF para comenzar", 'info')


def main():
    """Funci√≥n principal."""
    root = tk.Tk()
    app = CargadorMovimientosGUI(root)
    root.mainloop()


if __name__ == "__main__":
    main()
